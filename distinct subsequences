public class Solution {
    /**
     * @param S, T: Two string.
     * @return: Count the number of distinct subsequences
     */
    public int numDistinct(String S, String T) {
        // write your code here
        
        //思路:动规，题意就是在S当中能挑出多少个T
        if(S == null || T == null)
        {
            return 0;
        }
       
        int[][] result = new int[S.length() + 1][T.length() + 1];
        for(int i = 0; i <= S.length(); i++)
        {
            result[i][0] = 1; //在s当中挑出t的空串总有一种方案；而第一行默认就是０(j > 0),除了第一个)，意思就是在空串当中挑不出来T当中的内容；这也是比较独特的初始化i和j不一样的一道题
        }
        
        for(int i = 1; i <= S.length(); i++) //S或者T中有空串的情况也包括在内了，有空串循环有一个肯定不能执行，然后直接返回值(第一行尾或第一列尾)
        {
            for(int j = 1; j <= T.length(); j++)
            {
                result[i][j] = result[i - 1][j]; //保留上次匹配的结果，在S未加入新字母之前的结果
                if(S.charAt(i - 1) == T.charAt(j - 1))
                {
                    result[i][j] = result[i - 1][j - 1] + result[i - 1][j]; //左上+上
                }
            }
        }
        return result[S.length()][T.length()];
    }
}
