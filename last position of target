class Solution {
    /**
     * @param nums: The integer array.
     * @param target: Target to find.
     * @return: The first position of target. Position starts from 0.
     */
    public int binarySearch(int[] nums, int target) {
        //write your code here
      if(nums == null || nums.length == 0)
      {
          return -1;
      }
      int start = 0, end = nums.length - 1;
      while(start + 1 < end)
      {
          int mid = start + (end - start) / 2; //这样写是为了防止溢出
          //（装逼用，就是end+start可能比int的最大值还要大，防止int的溢出）
          if(nums[mid] <= target) //跟fisrtposition不一样的地方就是这里多个等号，
          //结果就是start不断地往后窜，直到找到最后一个重复的元素
          {
              start = mid;
          }
          else
          {
              end = mid;
          }
      }
      
      if(nums[start] == target)
      {
          return start;
      }
      
      if(nums[end] == target)
      {
          return end;
      }
      
      return -1;
    }
}
