class Solution {
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    public ArrayList<ArrayList<Integer>> subsets(int[] nums) {
        // write your code here
        //递归方法：递归树
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>(); //装ArrayList的ArrayList
        if(nums == null || nums.length == 0)
        {
            return result;
        }
        ArrayList<Integer> list = new ArrayList<Integer>();
        Arrays.sort(nums); //排个序
        
        subsetsHelper(result, list, nums, 0); //调用找出子集函数
        
        return result;
    }
    
    private void subsetsHelper(ArrayList<ArrayList<Integer>> result, ArrayList<Integer> list, int[] nums, int pos)
    {
        result.add(new ArrayList<Integer>(list)); //每次都要加
        
        for (int i = pos; i < nums.length; i++) 
        {
            list.add(nums[i]); //按照顺序先加入1
            subsetsHelper(result, list, nums, i+1); //把所有开头位1的找出子集
            list.remove(list.size()-1);//把1删掉换成下一个数
            //可以这么理解，正经的运行过程得自己画图
        }
    }
    
         //非递归的方法,共0~7个数
        //0 ->000 -> []
        //1 ->001 -> [3]
        //2 ->100 -> [1]
        //3 ->010 -> [2]
        //4 ->111 -> [1,2,3]
        //复杂度是o(n*2^n),比如n=3，对三个数进行排列，总共有2^n个子集，每个子集都要扩展成n位数(000这样的)
        public ArrayList<ArrayList<Integer>> subsets(int[] nums)
        {
            ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();
            if(nums == null || nums.length == 0)
            {
                return results;
            }

            int n = nums.length;
            Arrays.sort(nums);
            
            for(int i = 0; i < (1 << n); i++) //2^n个子集，循环2^n次，把每个数都比较一次
            {
                ArrayList<Integer> list = new ArrayList<Integer>();
                for(int j = 0; j < n; j++) //把每位数扩展成n位
                {
                    if((i & (1 << j)) != 0) //让i与每种情况都按位与,注意有括号
                    {
                        list.add(nums[j]); //把相应的每位的组成加入
                    }
                }
                results.add(list); //第一次匹配是什么都没有，新建的list自然为空，然后就把空集的情况加进去了，以后都是加入相应的子集
            }
            return results;
        }
}
